## 이력서 *<small><update 21.02.04><small>*

### 소개
- 이름: 조민호
- 나이: 1996.06.07
- 병역: 공군병장 만기제대
- 깃허브: [Github](https://github.com/Mino777)
- 이메일: jomino7777@gmail.com

> 안녕하세요, 소통을 바탕으로 협업하는 iOS 개발자, 조민호입니다.
><br> iOS 교육 수료, 앱 런칭, 외주 프로젝트 참여 경험을 바탕으로 준비된 iOS 개발자의 역량을 발휘하고,
><br> 서버 개발자, 디자이너, 기획자와 협업한 경험을 바탕으로 원활하게 소통하는 iOS 개발자가 되겠습니다.
><br> 감사합니다.
---

### 학력

**경기대학교 스포츠산업경영학과** : 2014.03 ~ 2021.02 (졸업)

---

### 경력

**(프리랜서) 그래비룸, iOS 개발자** : 2020.12 ~ 2021.02
- iOS MVP 개발 및 기획 참여
- Grap App v1.0.0(1) ~ v1.0.0(14) 개발

**(프리랜서) 소프트스퀘어드, iOS 개발자** : 2020.8 ~ 2020.12
- iOS 개발
- Conti App v1.0.0(1) ~ v1.0.8 앱 런칭, 개발 및 유지보수

---
### 활동
- **2021.01.29**
	- Wanted Live Talk 성장하는 iOS 개발자 세미나 참가
	   - 새로운 지식을 얻는 방법
	   - 프로젝트를 여러명이서 같이 개발할 때 생기는 문제점과 해결방안
	   - BDD를 시작하는 방법
- **2020.08.19**
	- 2020 NAVER TECH CONCERT 참가
	   - 주니어 개발자의 성장 방향
	   - 적절한 자료구조 사용에 대한 필요성
	   - 좋은 동료가 되기 위한 노력
	   - 빌드 속도를 향상시키는 방법
- **2020.05 ~ 2020.07**
  - 소프트스퀘어드 컴공선배 라이징 프로그래머 1기 수료
    - iOS 프로그래밍, 업무 프로세스 교육 수료
    - VIBE Clone App 제작 및 Demo Day 시연 및 발표
    - [컴공선배 유투브 라이징 프로그래머 출연](https://www.youtube.com/watch?v=PGYyzqN3CGQ)
- **2020.03 ~ 2020.04**
  -  한국기술교육대학교 온라인평생교육원 리눅스 시스템과 네트워크 프로그래밍 교육 수료
- **2020.02 ~ 2020.03**
	- 경기대학교 취업동아리 KCCP 22기 IT팀 iOS 멘티 (코로나로 인해 중단 및 미수료)
 - **2019.09 ~ 2019.12**
	  - goorm 주최 온라인 개발자 육성 과정 DevelUP 1기 수료
		  - HTML, CSS, JavaScript, Nodejs를 이용한 웹 프로그래밍 교육 수료
		  - DevelUP Web 부분 세미나 및 밋업 참가
		  - DevelUP 모각코 모임 참가
		  - DevelUPxNHN 해커톤 참가

---

### 외국어

- 영어
    - OPIC IM1 (2020.12.03)
    - 공식 문서를 읽고 영어로된 강의를 듣는 것에 어려움을 느끼지 않습니다.

---

### 프로젝트

## :pushpin: Conti

**사진을 이용한 SNS 어플리케이션**

> 현재는 AR기능이 추가되었는데, 저는 AR기능이 추가되기 직전 버전까지 개발하였습니다.

#### [Conti 시연 영상](https://youtu.be/Tj1QKvsx8yw)

#### [AppStore](https://itunes.apple.com/kr/app/id1537755211#?platform=iphone)

<details>
<summary><b>Conti 프로젝트 상세 보기</b></summary>
<div markdown="1">
	
---

#### 1. 제작 기간 & 참여 인원
- 2020.8.24 ~ 2020.12.31
- CM 1명 / PM 1명 / DL(개발 리드) 1명 / DM(개발 실무자) 2명 (IOS, PHP) / DL(디자이너 리드) 1명 / DM(디자인 실무자) 1명 (Sketch, Zeplin)

---

#### 2. 기능
1. 카카오, 페이스북, 구글, 애플 SNS 로그인 가능 및 회원가입을 하지 않고 제한된 활동을 할 수 있는 게스트 로그인 가능.
2. Feed를 통해 팔로우한 유저들의 게시글 확인, 수정, 삭제, 좋아요, 댓글작성, 삭제, 신고, 팔로우 확인, 유저 신고&차단 가능.
3. Search를 통해 전체 유저를 대상으로 해시태그, 검색된 게시물의 이미지 확인, 아이디 검색 가능.
4. Creation을 통해 일자형, 십자형 게시글 (사진 + 글) 등록 가능, 글 작성시 #, @ 사용시에 사용자 목록이 나오고 터치시 자동완성 및 해시태그, 멘션 가능.
5. 팔로우, 좋아요, 멘션시 해당 유저에게 Push Notification 발송.
6. Notification을 통해 날짜, 시간별로 팔로우, 좋아요, 멘션 알림 확인 가능
7. Profile을 통해 팔로우, 팔로워 목록, 자신의 게시글 확인, 상대 유저 팔로우, 유저 신고&차단, 연락처를 통한 게시글 공유, 친구초대 가능.

---

#### 3. 사용한 아키텍쳐

- MVC / Delegation / Singleton

---

#### 4. 사용한 기술 및 라이브러리

- 형상관리: GitLab
- Tool: Slack /  Google Sheets /  Google Driver /  Zeplin /  Xcode /  Postman /  Sourcetree
- UI: Storyboard(Main) / Xib + Code /  다크 모드 금지 대응
- Swift5 / Xcode10 / TestFlight /  REST API /  CocoaPods /  UIKit /  Auto Layout /  GCD /  UserNotifications /  Error Handling /  Localizing /  Networking / Custom Extension /  Contacts
- 'Alamofire', '~> 4.9.1' (DataManager로 만들어 네트워킹 관리)
- 'AlamofireNetworkActivityIndicator', '~> 2.4.0'
- 'AlamofireObjectMapper', '~> 5.2.1' (Entity, Response 생산성을 높이기 위해 사용)
- 'SnapKit' , '~> 5.0.1'
- 'Firebase/Analytics' , '~> 7.0.0'
- 'Firebase/Crashlytics', '~> 7.0.0'
- 'Firebase/Core', '~> 7.0.0'
- 'Firebase/Auth', '~> 7.0.0'
- 'GoogleSignIn', '~> 5.0.2'
- 'Firebase/Storage', '~> 7.0.0' (이미지, 서비스 이용약관, 개인정보 처리방침 저장)
- 'Kingfisher', '~> 5.15.7' (이미지 비동기 처리, 이미지 캐싱, downsampling, indicator 활용)
- 'FBSDKLoginKit', '~> 8.1.0'
- 'RxKakaoSDK', '~> 2.0.0-beta.3'
- 'RxSwift', '~> 5.1.1' (카카오 로그인 부분만 RxSwfit를 사용했습니다)
- 'RxCocoa', '~> 5.1.1' (Alamofire와 KakaoSDK 충돌로 인해 RxKakaoSDK 사용)
- 'Firebase/DynamicLinks', '~> 7.0.0' (친구 추천 기능을 위한 동적 링크 활용)
- 'Firebase/Messaging', '~> 7.0.0' (Push Notification 활용)
- 'Mantis', '~> 1.4.4' (Image Crop 기능에서 생산성을 높이기 위해 사용)
- 'Atributika', '~> 4.9.10' (해시태그 기능에서 NSAttributedString 터치 감지를 위해 사용)

---

#### 5. 핵심 트러블 슈팅

- 기본적인 문제 해결 루트
  - 공식 문서 활용.
  - 구글링한 자료를 응용해서 내 상황에 맞게 소화시키기 / 블로그, 유투브 등 정제되지 않은 자료 활용.
  - 10분간 리프레쉬. (잠깐 쉬었다가 다시 보는 경우에 해결되는 문제들이 있음)
  - 각종 커뮤니티 및 사수님께 질문. (질문하기 전에 최대한 깔끔하게 질문하려고 질문을 정제하다보면 해결되는 경우가 많음)
  - 이정도로도 안될시, 해당 태스크의 우선순위를 미루고 다른 태스크를 하며 관련 라이브러리를 찾아서 뜯어보는 등 사수님과 함께 고민.
  
#### 5.1. 페이징 처리 문제
- 기존엔 단순히 서버 개발자와 협의하여 네트워킹시에 get 파라미터에 페이지를 추가하고, 추가된 데이터를 기존 데이터 배열에 추가해주는 방식으로 진행.
- 스크롤을 빠르게 내리거나, refresh 시에 비정상적으로 페이징 처리가 되는 이슈.
- ViewController에서 변수를 추가해 정확한 조건에 해당할 때만 DataManager 인스턴스를 호출하는 방식으로 해결.
<details>
<summary><b>🧑‍💻 관련 코드 보기</b></summary>
<div markdown="1">
	
~~~swift
// MARK: 페이징 관련 변수들
    let contentsPerPage = 10
    var isRequesting: Bool = true
    var isEnd: Bool = false

// MARK: 피드 화면 데이터 요청이 성공할 경우 동작
    func didRetrieveContents(contents: [FeedContentResult]) {
        isRequesting = false
        isEnd = contents.count < contentsPerPage
        self.contents += contents
        noResultLabel.isHidden = self.contents.count > 0
        feedCollectionView.reloadData()
        dismissIndicator()
    }
// MARK: 특정 조건이 부합했을 때 DataManager 인스턴스를 호출
   if !isRequesting && !isEnd && indexPath.row >= contents.count - contentsPerPage/3 {
        isRequesting = true
        let page = (contents.count + contentsPerPage) / contentsPerPage
        FeedContentDataManager().getFeedContent(self, page: page)
    }
~~~

</div>
</details>

#### 5.2 해시태그 기능
- 해시태그 기능의 경우 구현 난이도가 너무나도 높았었음.
- 관련 회의에서 총 3가지의 해시태그 구현 방식이 나왔고, 그 중에 최대한 난이도를 낮춘 방법을 택하게 됨.
- 클라쪽에서 태그에 관한 속성을 설정해주고 제작 상세화면에서 게시글 작성시에 해당 속성에 부합하는 경우 String -> attributedString으로 변환하고 해당 되는 문자열을 추출해 서버에 태그 유저 리스트 조회 요청 파라미터에 넣어 전달.
- 그리고 해당 목록의 유저를 탭하면 자동완성을 시켜 안정성을 향상시키고 서버에서는 @이 포함된 문자열을 해시태그로 인식하는 방식으로 구현.

<details>
<summary><b>🧑‍💻 관련 코드 보기</b></summary>
<div markdown="1">
	
~~~swift
// MARK: 해시태그, 멘션 관련 string -> attributedString 변환 작업 및 서버에 태그 유저 리스트 조회 요청
    func textViewDidChange(_ textView: UITextView) {
        if let tag = textView.getCurrentTag(symbol: "@"), tag.count > 0 {
            // MARK: 여기서 사용자 목록 요청
            self.tagUserListSuperView.isHidden = false
            TagUserListDataManager().getTagUserListInProduce(self, tag)
            print(tag)
        } else {
            self.tagUserListSuperView.isHidden = true
        }
        
        let attributedText = textView.text.getTagAttributedString(location: textView.selectedRange.location)
        let location = textView.selectedRange.location
        if attributedText.string.count > textView.text.count {
            textView.attributedText = attributedText
            textView.selectedRange = NSMakeRange(min(location + 1, textView.text.count), 0)
        } else {
            textView.attributedText = attributedText
            textView.selectedRange = NSMakeRange(location, 0)
        }
    }

// MARK: 현재 입력중인 태그 추출 ( UITextView Extension )
    func getCurrentTag(symbol: Character = "@") -> String? {
        let offset = self.offset(from: self.beginningOfDocument, to: self.selectedTextRange!.start)
        for (i, char) in self.text.substring(range: 0..<offset).reversed().enumerated() {
            if char == symbol {
                return self.text.substring(range: (offset - i)..<offset)
            } else if char == " " {
                break
            }
        }
        return nil
    }

// MARK: substring ( String Extension )
    func substring(from: Int, to: Int) -> String {
        guard (to >= 0) && (from <= self.count) && (from <= to) else {
            return ""
        }
        let start = index(startIndex, offsetBy: max(from, 0))
        let end = index(start, offsetBy: min(to, self.count) - from)
        return String(self[start ..< end])
    }
    
    func substring(range: Range<Int>) -> String {
        return substring(from: range.lowerBound, to: range.upperBound)
    }
    
    // MARK: indexing
    func get(_ index: Int) -> String {
        return self.substring(range: index..<index)
    }
    
    // MARK: 태그 속성 설정
    func getTagAttributedString(location: Int? = nil) -> NSMutableAttributedString {
        let attributedText = NSMutableAttributedString()
        
        let plainAttributes: [NSAttributedString.Key : Any] = [
            .foregroundColor : UIColor(named: "gray84") as Any,
            .font : UIFont(name: "AppleSDGothicNeo-Medium", size: 15)!,
        ]
        let mentionAttributes: [NSAttributedString.Key : Any] = [
            .foregroundColor : UIColor(named: "tagColor") as Any,
            .font : UIFont(name: "AppleSDGothicNeo-Medium", size: 15)!,
        ]
        let hashtagAttributes: [NSAttributedString.Key : Any] = [
            .foregroundColor : UIColor(named: "tagColor") as Any,
            .font : UIFont(name: "AppleSDGothicNeo-Medium", size: 15)!,
        ]
        
        var type: Int = -1       // -1 : no type, 0 : plain, 1 : mention(@), 2 : hashtag(#)
        for char in self {
            switch (char, type) {
            case ("@", type) where type != -1:
                attributedText.append(NSAttributedString(string: " "))
                type = 1
            case ("@", _):
                type = 1
            case ("#", type) where type != -1:
                attributedText.append(NSAttributedString(string: " "))
                type = 2
            case ("#", _):
                type = 2
            case (" ", _), ("\n", _):
                type = -1
            case (_, 0), (_, -1):
                type = 0
            default:
                break
            }
            switch type {
            case 1:
                attributedText.append(NSAttributedString(string: String(char), attributes: mentionAttributes))
            case 2:
                attributedText.append(NSAttributedString(string: String(char), attributes: hashtagAttributes))
            default:
                attributedText.append(NSAttributedString(string: String(char), attributes: plainAttributes))
            }
        }
        return attributedText
    }
~~~

</div>
</details>

#### 5.3 Contacts를 사용한 친구초대 기능
- 연락처를 정렬을 할 때, 처음엔 배열을 자음 배열, 연락처 배열만 가지고 구현을 하려고 했었는데 이렇게 구현할 경우에 추후에 데이터를 넣는 과정에서 데이터들이 꼬이는 이슈가 있었음.
- 자음 정렬 배열, 연락처 정렬 배열을 따로 만들어서 데이터를 불러올때 넣어주는 방식으로 해결.
<details>
<summary><b>🧑‍💻 관련 코드 보기</b></summary>
<div markdown="1">
	
~~~swift
// MARK: 연락처 요청 함수
    func requestConstacts() {
        let store = CNContactStore() // 연락처 저장소
        let keys = [CNContactFormatter.descriptorForRequiredKeys(for: .fullName), CNContactPhoneNumbersKey as CNKeyDescriptor] //연락처 키
        let request = CNContactFetchRequest(keysToFetch: keys) // 연락처 요청 메소드
        print("연락처 찾기")
        do {
            var contacts: [CNContact] = []
            try store.enumerateContacts(with: request) { contact, stop in
                if !contact.phoneNumbers.isEmpty {
                    contacts.append(contact)
                }
            }
            
            for contact in contacts { // 연락처 어떻게 불러올건지 설정
                var phoneNumber = contact.phoneNumbers[0].value.value(forKey: "digits") as? String
                phoneNumber = phoneNumber?.trimmingCharacters(in: .whitespacesAndNewlines)
                phoneNumber = phoneNumber?.replace(target: "+8210", withString: "010")
                phoneNumber = phoneNumber?.replace(target: "+82010", withString: "010")
                phoneNumber = phoneNumber?.replace(target: "-", withString: "")
                
                let name = (contact.familyName + contact.givenName).trim
                guard name.count > 0 else { continue }
                if let consonant = name.consonant {
                    if !self.consonants.contains(consonant) {
                        self.consonants.append(consonant)
                        self.contacts[consonant] = []
                    }
                    self.contacts[consonant]?.append((name, phoneNumber))
                }
            }
            self.consonants.sort() // 자음 정렬
            self.consonants.forEach { consonant in
                self.contacts[consonant]?.sort(by: { lhs, rhs -> Bool in
                    return lhs.name < rhs.name
                })
            }
            self.filteredConsonants = self.consonants
            self.filteredContacts = self.contacts
            
            tableView.reloadData()
            print("연락처 요청 성공")
        } catch {
            self.presentAlert(title: "연락처 정보를 불러올 수 없습니다.") { action in
                self.navigationController?.popViewController(animated: true)
            }
        }
    }
~~~

</div>
</details>

#### 6. 그 외 트러블 슈팅

##### 6.1. 앱 런칭 심사때 Contacts 사용시, 디바이스에 저장을 하는 것인지, 불러와서 띄워주기만 하는 것인지에 대한 불명확성의 이유로 리젝.
- 저장하지 않고 불러와서 띄워주기만 한다고 답변하여 해결.

##### 6.2. 카카오 로그인을 위해 KakaoSDK 라이브러리 사용시 pod에서 Alamofire와 KakaoSDK 버전 충돌.
- RxKakaoSDK 특정 버전을 사용해 해결.
  
##### 6.3. ViewController가 점점 무거워지는 상황
- TableView, CollectionView를 사용하는 경우 각 Cell에 updateUI 함수를 만들어 최대한 각자 역할을  명확하게 해주는 방식 사용.

---

#### 7. 회고
- 훌륭한 팀원 분들을 얻을 수 있었고, 개발에 대해서 정말 많은 것을 보고 배운 프로젝트이며 개발자라는 직업을 내 인생의 평생 업으로 삼고 싶다 라는 확신을 준 프로젝트.
- 기획자, 개발리더, 디자이너, 서버 개발자분들과 정말 많은 소통을 하며 개발 스킬 뿐만 아니라, 커뮤니케이션 스킬과 관련 용어 습득이 많이 늘어나게 되었음.
- 업무 프로세스에 대해 나만의 루틴이 생기고, 견고한 태스크 리스트를 짤 수 있게 되면서 이전보다 체계적으로 주어진 업무를 수행할 수 있게 되었음.
- MVVM, Clean Swfit(VIP)등 다른 디자인 패턴을 적용시켜보지 못하고 MVC 패턴을 사용한 부분이 아쉬움.
- Protocol에 대한 이해도가 부족해 적용을 못시켜본 부분이 아쉬움.
- 확장성있는 코드에 대한 깊은 고민이 부족했던 부분이 아쉬움.
- 프로젝트를 진행하고 꽤 많은 시간이 흐른 뒤에 정리하다보니 조금 휘발된 기억들이 있어 많이 아쉬움. 앞으로는 나를 위해 프로젝트를 진행하면서 꼭 바로바로 정리해두는 습관을 길러야할 것 같다.

</div>
</details>

---

## :pushpin: Grap

**그림일기를 통해 다양한 사람들과 일상을 공유하는 그림일기 SNS 어플리케이션**

> 기존에 있던 안드로이드 앱을 참고로 iOS MVP 개발을 진행 하였고, 추후 새로운 iOS 개발자 분 채용시에 출시 예정입니다.

<img src="resume/Grap_Image/IMG_2567.PNG" width="150">
<img src="resume/Grap_Image/IMG_2568.PNG" width="150">
<img src="resume/Grap_Image/IMG_2569.PNG" width="150">
<img src="resume/Grap_Image/IMG_2570.PNG" width="150">
<img src="resume/Grap_Image/IMG_2571.PNG" width="150">
<img src="resume/Grap_Image/IMG_2572.PNG" width="150">

#### [Google Play Store](https://play.google.com/store/apps/details?id=com.softsquared.grap&hl=ko&gl=US)
#### AppStore 추후 출시 예정

<details>
<summary><b>Grap 프로젝트 상세 보기</b></summary>
<div markdown="1">
	
---

#### 1. 제작 기간 & 참여 인원
- 2020.12.01 ~ 2021.02.01
- PM 1명 / AOS 2명 / iOS 1명 / PHP 1명 / 디자이너 1명 (Sketch, Zeplin)

---

#### 2. 기능
1. 메인 탭에서 최신순, 인기순으로 유저들의 공개 그림 일기 확인 및 상세 화면에서 좋아요 가능, 탭바에서 메인 탭 터치시 최상위 인덱스로 이동 가능.
2. 검색에서 유저 필명, 게시글에 포함된 내용 대상으로 검색 가능. 내 게시물 검색 가능.
3. 그림 그리기 탭에서 그림 그리기 -> 일기 작성 가능.
4. 그림 그리기시, 펜, 마커, 연필, 지우개, 페인트 도구 사용 가능. Custom Color Picker로 색상 선택 가능. 펜, 마커, 연필의 경우 슬라이드를 이용해 두께 조절 가능.
5. 일기 작성시 제목, 날씨, 일기 내용, 글 정렬, 공개/비공개 설정 가능.
6. 마이페이지 탭에서 프로필 그림 다시 그리기, 필명 및 소개글 재작성 가능. 나의 일기 년도별, 날짜별 확인 가능. 나의 일기 공개/비공개 설정 및 삭제 가능. 자신이 좋아요한 목록 확인 가능.
7. 설정에서 프로필 재설정, 좋아한 게시물, 게시물 전체 공개/비공개, 게시물 전체 삭제, 로그아웃 및 회원탈퇴 가능.

---

#### 3. 사용한 아키텍쳐

- MVC / Delegation / Singleton

---

#### 4. 사용한 기술 및 라이브러리

- 형상관리: Github
- Tool: Slack / Meister Task / Notion / Google Sheets / Zeplin / Xcode / Postman / Sourcetree
- UI: No Storyboard / Xib + Code / 다크 모드 금지 대응
- Swift5 / Xcode10 / TestFlight / REST API / CocoaPods / UIKit /  Auto Layout / GCD / UserNotifications / Error Handling / Localizing / Networking / Custom Extension / PKCanvas / PKDrawing / PKTool / CoreImage
- 'Alamofire' (DataManager로 만들어 네트워킹 관리)
- 'AlamofireNetworkActivityIndicator'
- 'AlamofireObjectMapper' (Entity, Response 생산성을 높이기 위해 사용)
- 'SnapKit'
- 'Firebase/Analytics'
- 'Fabric'
- 'Crashlytics'
- 'Firebase/Core'
- 'Kingfisher' (이미지 비동기 처리, 이미지 캐싱, downsampling 활용)
- 'Firebase/Storage' (그림 이미지, 프로필 이미지, 배너 저장)

---

#### 5. 핵심 트러블 슈팅

- 기본적인 문제 해결 루트
  - 공식 문서 활용.
  - 구글링한 자료를 응용해서 내 상황에 맞게 소화시키기 / 블로그, 유투브 등 정제되지 않은 자료 활용.
  - 10분간 리프레쉬. (잠깐 쉬었다가 다시 보는 경우에 해결되는 문제들이 있음)
  - 각종 커뮤니티에 질문. (질문하기 전에 최대한 깔끔하게 질문하려고 질문을 정제하다보면 해결되는 경우가 많음)
  - 이정도로도 안될시, 해당 태스크의 우선순위를 미루고 다른 태스크를 하며 관련 라이브러리를 찾아서 뜯어보는 등 깊게 고민.

#### 5.1 안드로이드 및 태블릿에서 이미지가 깨지는 이슈
- 아이폰 전기종에선 이미지가 깨지는 이슈가 없었으나, 안드로이드에서 디스플레이 크기가 큰 디바이스 및 갤럭시 탭에서 이미지가 깨짐.
- 이미지를 저장할 때, scaleFactor를 3으로 올리고 이미지를 CoreImage로 변환하고 size를 1080x1080 으로 resize 해서 해결.

<details>
<summary><b>🧑‍💻 관련 코드 보기</b></summary>
<div markdown="1">
	
~~~swift
// MARK: image resize 및 storage upload
	let image = self.canvasImage
        guard image != nil else {
            presentAlert(title: "이미지가 저장되지 않았습니다.", message: "")
            return
        }
        
        let saveImage = image?.resizeCI(size: CGSize(width: 1080, height: 1080))?.pngData()
        
        if let data = saveImage {
            self.showIndicator()
            PhotoUploadDataManager().getPhotoUpload(data, VC: self)
        } else {
            self.presentAlert(title: "이미지를 불러올 수 없습니다")
        }
	
// MARK: CoreImage로 변환
   func resizeCI(size:CGSize) -> UIImage? {
        let scale = (Double)(size.width) / (Double)(self.size.width)
        let image = UIKit.CIImage(cgImage:self.cgImage!)
        
        let filter = CIFilter(name: "CILanczosScaleTransform")!
        filter.setValue(image, forKey: kCIInputImageKey)
        filter.setValue(NSNumber(value:scale), forKey: kCIInputScaleKey)
        filter.setValue(3.0, forKey:kCIInputAspectRatioKey)
        let outputImage = filter.value(forKey: kCIOutputImageKey) as? UIKit.CIImage
        
        let context = CIContext(options: [CIContextOption.useSoftwareRenderer: false])
        let resizedImage = UIImage(cgImage: context.createCGImage(outputImage, from: outputImage.extent) ?? self.image)
        return resizedImage
    }
~~~

</div>
</details>

#### 6. 그 외 트러블 슈팅

##### 6.1 그림 그리기 툴 커스텀
- AOS의 경우 그림 그리기 툴이 프레임워크에 내장되어있는 라이브러리가 없어서 직접 만듦.
- iOS의 경우 PencilKit이라는 내장 라이브러리가 있었고, 그 안에있는 PKToolPicker class가 정말 간단하게 사용이 가능했음. 하지만 Grap의 경우 그림 그리기 툴의 이미지에 커스텀이 필요했고, PencilKit은 커스텀이 불가능했음.
- 공식 문서를 계속해서 파본 결과, PKCanvasView class 안에 PKTool Property가 있었고 PKToolPicker 보다 제한적이었지만 Grap의 요구사항을 충족시키고 커스텀이 가능하여 PKTool을 사용.

##### 6.2 TestFlight 빌드시 ITMS-90000: This bundle is invalid - $message 사유 리젝 
- 전혀 바뀐 설정이 없었고 구글링해도 이렇다할 해결법이 없어서 다른 사유의 해결과정을 시도. 
- 인증서 리셋 -> Provisioning 재연결 -> 팀아이디 재설정 및 클린 빌드 -> 맥 재부팅으로 해결. 
- 이전에 리젝된 버전들이 다음 날 새벽에 갑자기 한꺼번에 빌드됨 -> TestFlight 자체 이슈였음 

---

#### 7. 회고
- 개발 뿐만 아니라, 기획 및 마케팅 등 운영에 관한 회의들도 참석하면서 스타트업의 업무 방식 및 회의 방식을 습득할 수 있었고 사업에 관한 시야도 넓어지는 경험을 할 수 있었음.
- 외주 개발이었지만, iOS 개발자가 혼자였기 때문에 내가 회의에서 발의한 의견들이 적용되고 실제로 프로덕트에 담기는 경험이 굉장히 재밌었음.
- AOS 개발자분들과 처음으로 협업을 하면서 안드로이드 진영에 대한 지식을 쌓을 수 있었음.
- Conti 개발과 병행 + 개발 일정 등을 핑계로, Conti 개발 당시에 부족했던 부분들을 개인적으로 채우지 못하고 그저 사용해봤던 기술, 라이브러리, 코드 스타일, 디자인패턴 등을 그대로 사용해 너무나도 아쉬웠음.
- Git flow를 적용시켜보고 싶었지만 혼자 작업하니까 필요없겠지 라는 핑계로 그저 master branch 사용과 커밋 메세지, 이슈만 신경쓴 부분이 아쉬움.

</div>
</details>
